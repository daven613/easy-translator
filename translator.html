<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Easy Translator</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 650px;
      margin: 40px auto;
      padding: 20px;
      background: #f5f5f5;
    }
    h1 { text-align: center; color: #333; margin-bottom: 8px; }
    .subtitle { text-align: center; color: #666; margin-bottom: 24px; font-size: 14px; }
    .card {
      background: white;
      border-radius: 8px;
      padding: 24px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 16px;
    }
    .card-title {
      font-size: 14px;
      font-weight: 600;
      color: #666;
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    label {
      display: block;
      margin-bottom: 6px;
      font-weight: 500;
      color: #444;
    }
    input[type="text"], input[type="password"], input[type="file"], select, textarea {
      width: 100%;
      padding: 10px;
      margin-bottom: 16px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }
    textarea {
      min-height: 80px;
      resize: vertical;
      font-family: inherit;
    }
    button {
      width: 100%;
      padding: 12px;
      background: #2563eb;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 16px;
      cursor: pointer;
      margin-bottom: 8px;
    }
    button:hover { background: #1d4ed8; }
    button:disabled { background: #94a3b8; cursor: not-allowed; }
    .btn-secondary {
      background: #64748b;
    }
    .btn-secondary:hover { background: #475569; }
    .btn-success { background: #22c55e; }
    .btn-success:hover { background: #16a34a; }
    .progress {
      margin: 16px 0;
      display: none;
    }
    .progress-bar {
      height: 24px;
      background: #e2e8f0;
      border-radius: 4px;
      overflow: hidden;
    }
    .progress-fill {
      height: 100%;
      background: #22c55e;
      transition: width 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 12px;
      font-weight: 500;
    }
    .status { text-align: center; margin-top: 10px; color: #666; }
    .error { color: #dc2626; text-align: center; margin: 10px 0; }
    .hidden { display: none; }
    .row { display: flex; gap: 12px; }
    .row > * { flex: 1; }
    .api-key-row { display: flex; gap: 8px; }
    .api-key-row input { flex: 1; margin-bottom: 0; }
    .api-key-row button { width: auto; padding: 10px 16px; margin-bottom: 0; }
    .info { font-size: 12px; color: #666; margin-top: -12px; margin-bottom: 16px; }
    .chunks-info { font-size: 13px; color: #666; margin-bottom: 12px; }
  </style>
</head>
<body>
  <h1>Easy Translator</h1>
  <p class="subtitle">Translate large files using OpenAI - runs entirely in your browser</p>

  <!-- Settings Card -->
  <div class="card">
    <div class="card-title">Settings</div>

    <label for="apiKey">OpenAI API Key</label>
    <div class="api-key-row">
      <input type="password" id="apiKey" placeholder="sk-...">
      <button type="button" id="saveKeyBtn" class="btn-secondary">Save</button>
    </div>
    <p class="info">Your key is stored locally in your browser only.</p>

    <div class="row">
      <div>
        <label for="model">Model</label>
        <select id="model">
          <option value="gpt-5-nano">gpt-5-nano (fast & cheap)</option>
          <option value="gpt-5-mini">gpt-5-mini</option>
          <option value="gpt-5.2">gpt-5.2</option>
        </select>
      </div>
      <div>
        <label for="chunkSize">Chunk Size</label>
        <select id="chunkSize">
          <option value="2000">2000 chars</option>
          <option value="3000">3000 chars</option>
          <option value="4000" selected>4000 chars</option>
          <option value="6000">6000 chars</option>
        </select>
      </div>
    </div>
  </div>

  <!-- Translation Card -->
  <div class="card">
    <div class="card-title">Translate</div>

    <label for="file">File to translate</label>
    <input type="file" id="file" accept=".txt,.md,.html,.json,.csv">

    <label for="prompt">Translation prompt</label>
    <textarea id="prompt">Translate this text from French to English in a professional manner.</textarea>

    <button id="translateBtn">Translate</button>

    <div class="progress" id="progress">
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill">0%</div>
      </div>
      <div class="status" id="status">Starting...</div>
    </div>

    <div class="error" id="error"></div>

    <button class="btn-success hidden" id="downloadBtn">Download Translation</button>
  </div>

  <!-- Resume Card -->
  <div class="card hidden" id="resumeCard">
    <div class="card-title">Resume Previous Translation</div>
    <p class="chunks-info" id="resumeInfo"></p>
    <div class="row">
      <button id="resumeBtn">Resume</button>
      <button id="clearBtn" class="btn-secondary">Clear & Start Fresh</button>
    </div>
  </div>

  <!-- Premium Interest -->
  <div class="card" style="text-align:center;">
    <p style="margin:0 0 12px 0; color:#444;">Want batch processing, more models, and cloud sync?</p>
    <button onclick="Tally.openPopup('KY50Dg', {layout:'modal'})" style="background:#8b5cf6; padding:10px 24px;">
      Get notified about Premium
    </button>
  </div>
  <script async src="https://tally.so/widgets/embed.js"></script>

  <script>
    // DOM Elements
    const apiKeyInput = document.getElementById('apiKey');
    const saveKeyBtn = document.getElementById('saveKeyBtn');
    const modelSelect = document.getElementById('model');
    const chunkSizeSelect = document.getElementById('chunkSize');
    const fileInput = document.getElementById('file');
    const promptInput = document.getElementById('prompt');
    const translateBtn = document.getElementById('translateBtn');
    const progress = document.getElementById('progress');
    const progressFill = document.getElementById('progressFill');
    const status = document.getElementById('status');
    const error = document.getElementById('error');
    const downloadBtn = document.getElementById('downloadBtn');
    const resumeCard = document.getElementById('resumeCard');
    const resumeInfo = document.getElementById('resumeInfo');
    const resumeBtn = document.getElementById('resumeBtn');
    const clearBtn = document.getElementById('clearBtn');

    // State
    let db = null;
    let translatedChunks = [];
    let isTranslating = false;

    // Initialize
    async function init() {
      // Load saved API key
      const savedKey = localStorage.getItem('openai_api_key');
      if (savedKey) apiKeyInput.value = savedKey;

      // Load saved settings
      const savedModel = localStorage.getItem('openai_model');
      if (savedModel) modelSelect.value = savedModel;

      const savedChunkSize = localStorage.getItem('chunk_size');
      if (savedChunkSize) chunkSizeSelect.value = savedChunkSize;

      const savedPrompt = localStorage.getItem('translation_prompt');
      if (savedPrompt) promptInput.value = savedPrompt;

      // Initialize IndexedDB
      db = await openDatabase();

      // Check for pending work
      await checkPendingWork();
    }

    // IndexedDB setup
    function openDatabase() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open('EasyTranslator', 1);

        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);

        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains('chunks')) {
            const store = db.createObjectStore('chunks', { keyPath: 'id' });
            store.createIndex('status', 'status');
          }
          if (!db.objectStoreNames.contains('meta')) {
            db.createObjectStore('meta', { keyPath: 'key' });
          }
        };
      });
    }

    async function saveChunks(chunks, prompt) {
      const tx = db.transaction(['chunks', 'meta'], 'readwrite');
      const chunkStore = tx.objectStore('chunks');
      const metaStore = tx.objectStore('meta');

      // Clear existing
      await promisifyRequest(chunkStore.clear());

      // Save chunks
      for (let i = 0; i < chunks.length; i++) {
        await promisifyRequest(chunkStore.put({
          id: i,
          source: chunks[i],
          translated: null,
          status: 'pending'
        }));
      }

      // Save metadata
      await promisifyRequest(metaStore.put({ key: 'prompt', value: prompt }));
      await promisifyRequest(metaStore.put({ key: 'total', value: chunks.length }));
    }

    async function getChunks() {
      const tx = db.transaction('chunks', 'readonly');
      const store = tx.objectStore('chunks');
      return promisifyRequest(store.getAll());
    }

    async function updateChunk(id, translated, status) {
      const tx = db.transaction('chunks', 'readwrite');
      const store = tx.objectStore('chunks');
      const chunk = await promisifyRequest(store.get(id));
      chunk.translated = translated;
      chunk.status = status;
      await promisifyRequest(store.put(chunk));
    }

    async function getMeta(key) {
      const tx = db.transaction('meta', 'readonly');
      const store = tx.objectStore('meta');
      const result = await promisifyRequest(store.get(key));
      return result?.value;
    }

    async function clearDatabase() {
      const tx = db.transaction(['chunks', 'meta'], 'readwrite');
      await promisifyRequest(tx.objectStore('chunks').clear());
      await promisifyRequest(tx.objectStore('meta').clear());
    }

    function promisifyRequest(request) {
      return new Promise((resolve, reject) => {
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }

    // Smart chunking
    function splitTextIntoChunks(text, chunkSize = 4000) {
      const chunks = [];
      let startPos = 0;

      while (startPos < text.length) {
        if (startPos + chunkSize >= text.length) {
          chunks.push(text.substring(startPos));
          break;
        }

        const searchStart = startPos + Math.floor(chunkSize * 0.5);
        const searchEnd = startPos + chunkSize;
        const searchRegion = text.substring(searchStart, searchEnd);

        let breakOffset = -1;

        // Priority 1: Paragraph break
        const paragraphMatch = searchRegion.lastIndexOf('\n\n');
        if (paragraphMatch !== -1) {
          breakOffset = paragraphMatch + 2;
        }

        // Priority 2: Sentence ending
        if (breakOffset === -1) {
          for (let i = searchRegion.length - 1; i >= 0; i--) {
            const char = searchRegion[i];
            const prevChar = i > 0 ? searchRegion[i - 1] : '';
            if ((prevChar === '.' || prevChar === '!' || prevChar === '?') &&
                (char === ' ' || char === '\n')) {
              breakOffset = i;
              break;
            }
          }
        }

        // Priority 3: Comma
        if (breakOffset === -1) {
          for (let i = searchRegion.length - 1; i >= 0; i--) {
            if (searchRegion[i] === ' ' && i > 0 && searchRegion[i - 1] === ',') {
              breakOffset = i;
              break;
            }
          }
        }

        // Priority 4: Space
        if (breakOffset === -1) {
          const lastSpace = searchRegion.lastIndexOf(' ');
          if (lastSpace !== -1) breakOffset = lastSpace + 1;
        }

        const breakPos = breakOffset !== -1 ? searchStart + breakOffset : searchEnd;
        chunks.push(text.substring(startPos, breakPos));
        startPos = breakPos;
      }

      return chunks;
    }

    // OpenAI API call
    async function translateChunk(text, prompt, model, apiKey) {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: model,
          messages: [
            {
              role: 'system',
              content: `${prompt}\n\nPreserve the original formatting and paragraph breaks. Only output the translation, no explanations.`
            },
            { role: 'user', content: text }
          ],
          temperature: 0.3
        })
      });

      if (!response.ok) {
        const err = await response.json();
        throw new Error(err.error?.message || `API error: ${response.status}`);
      }

      const data = await response.json();
      return data.choices[0].message.content.trim();
    }

    // Check for pending work
    async function checkPendingWork() {
      const chunks = await getChunks();
      if (chunks.length === 0) {
        resumeCard.classList.add('hidden');
        return;
      }

      const pending = chunks.filter(c => c.status === 'pending').length;
      const completed = chunks.filter(c => c.status === 'success').length;
      const failed = chunks.filter(c => c.status === 'error').length;

      if (pending > 0 || failed > 0) {
        resumeInfo.textContent = `Found ${chunks.length} chunks: ${completed} completed, ${pending} pending, ${failed} failed`;
        resumeCard.classList.remove('hidden');
      } else if (completed === chunks.length) {
        // All done, offer download
        translatedChunks = chunks.map(c => c.translated);
        downloadBtn.classList.remove('hidden');
        resumeCard.classList.add('hidden');
      }
    }

    // Main translation process
    async function runTranslation(isResume = false) {
      const apiKey = apiKeyInput.value.trim();
      if (!apiKey) {
        error.textContent = 'Please enter your OpenAI API key';
        return;
      }

      error.textContent = '';
      translateBtn.disabled = true;
      resumeBtn.disabled = true;
      isTranslating = true;
      progress.style.display = 'block';
      downloadBtn.classList.add('hidden');

      const model = modelSelect.value;
      const chunkSize = parseInt(chunkSizeSelect.value);
      const prompt = promptInput.value;

      try {
        let chunks;

        if (!isResume) {
          // New translation
          const file = fileInput.files[0];
          if (!file) {
            throw new Error('Please select a file');
          }

          const text = await file.text();
          const textChunks = splitTextIntoChunks(text, chunkSize);

          await saveChunks(textChunks, prompt);
          chunks = await getChunks();
        } else {
          chunks = await getChunks();
        }

        const total = chunks.length;
        let completed = chunks.filter(c => c.status === 'success').length;

        // Process pending chunks
        for (const chunk of chunks) {
          if (!isTranslating) break; // Allow cancellation

          if (chunk.status === 'success') continue;

          status.textContent = `Translating chunk ${chunk.id + 1} of ${total}...`;

          try {
            const translated = await translateChunk(chunk.source, prompt, model, apiKey);
            await updateChunk(chunk.id, translated, 'success');
            completed++;
          } catch (err) {
            if (err.message.includes('429')) {
              status.textContent = 'Rate limited, waiting 20s...';
              await new Promise(r => setTimeout(r, 20000));
              // Retry
              try {
                const translated = await translateChunk(chunk.source, prompt, model, apiKey);
                await updateChunk(chunk.id, translated, 'success');
                completed++;
              } catch (retryErr) {
                await updateChunk(chunk.id, `[ERROR: ${retryErr.message}]`, 'error');
              }
            } else {
              await updateChunk(chunk.id, `[ERROR: ${err.message}]`, 'error');
            }
          }

          const percent = Math.round((completed / total) * 100);
          progressFill.style.width = `${percent}%`;
          progressFill.textContent = `${percent}%`;

          // Small delay between requests
          if (chunk.id < total - 1) {
            await new Promise(r => setTimeout(r, 500));
          }
        }

        // Done
        const finalChunks = await getChunks();
        translatedChunks = finalChunks.map(c => c.translated || `[MISSING CHUNK ${c.id + 1}]`);

        const successCount = finalChunks.filter(c => c.status === 'success').length;
        const errorCount = finalChunks.filter(c => c.status === 'error').length;

        status.textContent = `Done! ${successCount}/${total} chunks translated` +
          (errorCount > 0 ? ` (${errorCount} failed)` : '');

        progressFill.style.width = '100%';
        progressFill.textContent = '100%';
        downloadBtn.classList.remove('hidden');
        resumeCard.classList.add('hidden');

      } catch (err) {
        error.textContent = err.message;
      } finally {
        translateBtn.disabled = false;
        resumeBtn.disabled = false;
        isTranslating = false;
      }
    }

    // Download result
    function downloadResult() {
      const text = translatedChunks.map(t => t.trim()).join('\n\n');
      const blob = new Blob([text], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = 'translated.txt';
      a.click();

      URL.revokeObjectURL(url);
    }

    // Event listeners
    saveKeyBtn.addEventListener('click', () => {
      localStorage.setItem('openai_api_key', apiKeyInput.value.trim());
      localStorage.setItem('openai_model', modelSelect.value);
      localStorage.setItem('chunk_size', chunkSizeSelect.value);
      localStorage.setItem('translation_prompt', promptInput.value);
      saveKeyBtn.textContent = 'Saved!';
      setTimeout(() => saveKeyBtn.textContent = 'Save', 1500);
    });

    translateBtn.addEventListener('click', () => runTranslation(false));
    resumeBtn.addEventListener('click', () => runTranslation(true));

    clearBtn.addEventListener('click', async () => {
      await clearDatabase();
      resumeCard.classList.add('hidden');
      downloadBtn.classList.add('hidden');
      progress.style.display = 'none';
    });

    downloadBtn.addEventListener('click', downloadResult);

    // Auto-save settings on change
    modelSelect.addEventListener('change', () => localStorage.setItem('openai_model', modelSelect.value));
    chunkSizeSelect.addEventListener('change', () => localStorage.setItem('chunk_size', chunkSizeSelect.value));
    promptInput.addEventListener('blur', () => localStorage.setItem('translation_prompt', promptInput.value));

    // Initialize on load
    init();
  </script>
</body>
</html>
